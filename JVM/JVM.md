# 一、JAVA运行时数据区域

## 1.1 程序计数器

记录当前执行字节码文件的行号，一旦线程被挂起后方便恢复进程。线程私有。

## 1.2 虚拟机栈

用于描述方法的执行，每个方法执行都会创建一个栈帧，用于存储局部变量表、操作数栈、方法出口和动态链接等信息。线程私有。

每个方法从执行到结束，都是一个栈帧进入虚拟机栈和出栈的过程。

* 局部变量表：存放方法参数和方法内部定义的局部变量。
* 操作数栈：存入和取出各种类型的实际数值，是用于计算的临时数据存储区域。

## 1.3 堆

为对象分配内存空间，线程共享。

## 1.4 方法区

存放常量、静态变量、类信息等，线程共享。

## 1.5 运行时常量池



# 二、对象的创建

虚拟机遇到new指令，首先定位符号引用，检查该类是否已经被加载、解析和初始化过，如果没有，需执行类的加载过程。

## 2.1 **类加载的过程**

加载 --> 验证 --> 准备 --> 解析 --> 初始化 --> 使用 --> 卸载

1. 加载：

- 1-1 通过类的全限定名获取定义该类的二进制字节码；
- 1-2 将字节码文件存储在方法区；
- 1-3 在内存中（堆）实例化一个java.lang.Class对象。

2. 验证： 确保Class文件的字节码文件所包含的信息正确且安全。

- 2-1 文件格式验证：验证字节码中信息的格式是否符合规范；
- 2-2 元数据验证：验证字节码描述的信息是否符合规范；
- 2-3 字节码验证：确定程序语义是否合法、符合逻辑；
- 2-4 符号引用验证： 确保解析过程能够正常执行。

3. 准备：为类变量分配内存并赋初值。

- 3-1 内存分配仅针对类变量（静态变量），而实例变量将在对象实例化时随着对象一起在堆中分配；
- 3-2 赋初始值， 其他赋值将在初始化阶段完成。

4. 解析：虚拟机将常量池中的符号引用替换为直接引用。

- 4-1 符号引用是以一组符号来描述所引用的目标，可以使任何形式的字面量，只需能无歧义地定位到目标即可。
- 4-2 直接引用可以视是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄:
  - 4-2-1 指针指向类对象、类变量、类方法；
  - 4-2-2 相对偏移量指向实例变量和实例方法。

5. 初始化：执行类构造器< clinit >() 方法，按主观需求初始化类变量和其他资源。

## 2.2 分配内存

* 内存绝对规整：指针碰撞法
* 内存不规整：空闲列表

## 2.3 对象的存储布局

* 对象头
* 实例数据
* 对齐填充



# 三、垃圾回收

程序计数器、虚拟机栈和本地方法栈由于线程私有，内存随着线程的结束而回收。

垃圾回收的主要内存区域是java堆和方法区。

## 3.1 对象死亡

* 引用计数法

  对象每次被引用，计数器加1；引用失效，则计数减1.如果引用计数为0，意味着对象没有引用，即宣告死亡。

* 可达性分析

  从GC ROOT向下搜索，如果不存在引用链，则为不可达。

  不可达对象的死亡需要经历两次标记过程。

  * 首先检查对象是否有必要执行finalize()方法，如果对象没有重写finalize方法或者已经执行过一次finalize方法，则判定死亡。
  * 如果对象有必要执行finalize方法，执行，重要重新与引用链建立关联，则逃离死亡命运。

## 3.2 引用

* 强引用

  在程序中普遍存在的引用，被引用的对象永远不会垃圾回收。

* 软引用

  有用但非必需的引用，在内存溢出之前会对软引用对象进行二次回收，回收后内存仍然不足，才会报内存溢出异常。

* 弱引用

  弱引用对象下次垃圾回收到来时必定会被回收。

* 虚引用

## 3.3 垃圾回收算法

* 标记-清除

  标记需要回收的对象并清除。

  * 效率不高
  * 出现内存碎片

* 标记整理

  将存活的对象向一端移动，回收边缘的对象。

* 复制

  将内存划分为较大的Eden和两块大小相同的Survivor区域，内存分配只使用Eden和一块Survivor，回收时将存活对象放到空闲的Survivor，清除其他的对象。

前两个适合老年代（生存率较高）对象回收，复制算法适合新生代（每次回收都有大量对象死去）。

## **双亲委派模型**

类加载器：通过一个类的全限定名获取描述此类的二进制字节码文件

1. **四种类加载器**

- 1-1. Bootstrap ClassLoader:
  负责将存放在<JAVA_HOME>\lib目录下的类库加载到虚拟机内存中;
- 1-2. Extension ClassLoader:
  负责加载<JAVA_HOME>\lib\ext目录下的所有类库；
- 1-3. Applicatin ClasssLoader:
  负责加载Classpath上所指定的类库；
- 1-4. 自定义类加载器。

1. **逐级向上委托**

   自定义类加载器 --> Applicatin ClasssLoader  -->Extension ClassLoader --> Bootstrap ClassLoader

2. **父加载器加载失败则返回给子加载器加载**

比较两个类是否相等，需满足三个条件：

1. 来源于同一个class文件；
2. 被同一个虚拟机加载；
3.  由同一个类加载器加载


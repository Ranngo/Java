## **符号引用和直接引用**

## **类加载的过程**

加载 --> 验证 --> 准备 --> 解析 --> 初始化 --> 使用 --> 卸载

1. 加载：

- 1-1 通过类的全限定名获取定义该类的二进制字节码；
- 1-2 将字节码文件存储在方法区；
- 1-3 在内存中（堆）实例化一个java.lang.Class对象。

2. 验证： 确保Class文件的字节码文件所包含的信息正确且安全。

- 2-1 文件格式验证：验证字节码中信息的格式是否符合规范；
- 2-2 元数据验证：验证字节码描述的信息是否符合规范；
- 2-3 字节码验证：确定程序语义是否合法、符合逻辑；
- 2-4 符号引用验证： 确保解析过程能够正常执行。

3. 准备：为类变量分配内存并赋初值。

- 3-1 内存分配仅针对类变量（静态变量），而实例变量将在对象实例化时随着对象一起在堆中分配；
- 3-2 赋初始值， 其他赋值将在初始化阶段完成。

4. 解析：虚拟机将常量池中的符号引用替换为直接引用。

- 4-1 符号引用是以一组符号来描述所引用的目标，可以使任何形式的字面量，只需能无歧义地定位到目标即可。
- 4-2 直接引用可以视是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄:
  - 4-2-1 指针指向类对象、类变量、类方法；
  - 4-2-2 相对偏移量指向实例变量和实例方法。

5. 初始化：执行类构造器< clinit >() 方法，按主观需求初始化类变量和其他资源。

## **双亲委派模型**

类加载器：通过一个类的全限定名获取描述此类的二进制字节码文件

1. **四种类加载器**

- 1-1. Bootstrap ClassLoader:
  负责将存放在<JAVA_HOME>\lib目录下的类库加载到虚拟机内存中;
- 1-2. Extension ClassLoader:
  负责加载<JAVA_HOME>\lib\ext目录下的所有类库；
- 1-3. Applicatin ClasssLoader:
  负责加载Classpath上所指定的类库；
- 1-4. 自定义类加载器。

1. **逐级向上委托**

   自定义类加载器 --> Bootstrap ClassLoader --> Extension ClassLoader --> Applicatin ClasssLoader

2. **父加载器加载失败则返回给子加载器加载**

比较两个类是否相等，需满足三个条件：1. 来源于同一个class文件；2. 被同一个虚拟机加载；3. 由同一个类加载器加载

## **ArrayList和LinkedList的区别**

1. ArrayList对get和set的调用花费常数时间*O(N)*,对于add和remove的调用代价昂贵*O(N2)*
2. LinkedList对add的调用花费常数时间*O(N)*,对于get和set的调用代价昂贵*O(N2)*,对remove的调用同样低效，因为达到位置i的代价是昂贵的。



**@Conditional派生注解（Spring注解版原生的@Conditional作用）**

作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；

## **小技巧**

//TODO注释表示标记待完成的任务，方便随时快捷访问。